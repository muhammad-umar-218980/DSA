ðŸ“˜ C++ STL 

ðŸ’¡ Introduction
------------------
STL (Standard Template Library) provides pre-built classes and functions for common data structures and algorithms.
It has 4 main components:
- Containers
- Iterators
- Algorithms
- Functors (Function Objects)


ðŸš€ CONTAINERS
------------------

ðŸ”· Sequence Containers (Store data in linear sequence)

ðŸ“¦ Vector
   - Dynamic array
   - Syntax: vector<int> v;
   - Functions:
        v.push_back(10)  â†’ Add element at end
        v.size()         â†’ Return number of elements
        v.empty()        â†’ Check if empty
        v.front()        â†’ Access first element
        v.back()         â†’ Access last element
        v.pop_back()     â†’ Remove last element

ðŸ“¦ List
   - Doubly linked list
   - Syntax: list<int> l;
   - Functions:
        push_back(), push_front()
        pop_back(), pop_front()
        remove() â†’ Remove elements by value
        sort(), reverse()   // member functions of list

ðŸ“¦ Deque
   - Double-ended queue
   - Syntax: deque<int> dq;
   - Functions:
        push_back(), push_front()
        pop_back(), pop_front()


ðŸ”· Container Adaptors (Provide restricted interface, built on other containers)

ðŸ“¦ Stack
   - LIFO (Last In First Out)
   - Syntax: stack<int> st;
   - Functions:
        push(), pop()
        top() â†’ Access top element
        empty(), size()

ðŸ“¦ Queue
   - FIFO (First In First Out)
   - Syntax: queue<int> q;
   - Functions:
        push(), pop()
        front() â†’ Access front element
        back() â†’ Access back element
        empty(), size()

ðŸ“¦ Priority Queue
   - Default: max heap (largest element at top)
   - Min heap: priority_queue<int, vector<int>, greater<int>> pq;
   - Functions:
        push(), pop()
        top() â†’ Access top element


ðŸ”· Associative Containers (Automatically sorted using balanced BST)

ðŸ“¦ Set
   - Unique elements in sorted order
   - Syntax: set<int> s;
   - Functions:
        insert(), erase()
        find() â†’ Returns iterator to element
        count() â†’ Returns 1 if exists, 0 otherwise
        lower_bound() â†’ First element >= value
        upper_bound() â†’ First element > value

ðŸ“¦ MultiSet
   - Allows duplicate elements
   - Syntax: multiset<int> ms;

ðŸ“¦ Map
   - Stores key-value pairs, keys sorted
   - Syntax: map<int,string> mp;
   - Functions:
        insert(), erase()
        find(), count()

ðŸ“¦ MultiMap
   - Allows multiple same keys
   - Syntax: multimap<int,string> mmp;


ðŸ”· Unordered Containers (Based on hashing)

ðŸ“¦ Unordered Set
   - Unique elements, no order
   - Syntax: unordered_set<int> us;

ðŸ“¦ Unordered Map
   - Key-value pairs, not sorted
   - Syntax: unordered_map<int,string> ump;


âš¡ push vs emplace
   - push_back() â†’ copies or moves object
   - emplace_back() â†’ constructs in place (faster, avoids temporary)


ðŸš€ ITERATORS
------------------

ðŸ’¡ Definition
   - Objects that act like pointers, used to access container elements

ðŸ“‹ Types of Iterators
   - begin() â†’ first element
   - end() â†’ one past last element
   - rbegin() â†’ last element (reverse)
   - rend() â†’ one before first element (reverse)
   - advance(it, n) â†’ move iterator
   - next(it), prev(it) â†’ step forward/backward

ðŸ’» Example
   vector<int> v = {10,20,30};
   for(auto it = v.begin(); it != v.end(); it++) {
       cout << *it << " ";
   }


ðŸš€ ALGORITHMS
------------------

ðŸ”„ Sorting
   - sort(v.begin(), v.end()) â†’ ascending
   - sort(v.begin(), v.end(), greater<int>()) â†’ descending
   - stable_sort() â†’ keeps equal elements in original order

ðŸ” Searching
   - find(v.begin(), v.end(), x) â†’ iterator to x
   - binary_search(v.begin(), v.end(), x) â†’ true/false

ðŸ“ Bounds
   - lower_bound(v.begin(), v.end(), x) â†’ first element >= x
   - upper_bound(v.begin(), v.end(), x) â†’ first element > x

ðŸ“Š Other Useful Algorithms
   - reverse() â†’ reverse order
   - max_element() â†’ largest element
   - min_element() â†’ smallest element
   - accumulate() â†’ sum of elements (from <numeric>)
   - count() â†’ frequency of element
   - next_permutation(), prev_permutation()


ðŸš€ FUNCTORS (FUNCTION OBJECTS)
------------------

ðŸ’¡ Definition
   - Class/struct that overloads operator ()
   - Acts like a function but can store states

ðŸ§© Built-in Functors
   - Arithmetic: plus<int>(), minus<int>(), multiplies<int>(), divides<int>()
   - Relational: equal_to<int>(), greater<int>(), less<int>()
   - Logical: logical_and<bool>(), logical_or<bool>(), logical_not<bool>()

ðŸŽ›ï¸ Custom Comparators
   struct cmp {
       bool operator()(int a, int b) const {
           return a > b;   // descending order
       }
   };
   sort(v.begin(), v.end(), cmp());


ðŸš€ UTILITIES
------------------

ðŸ“¦ Pair
   - Stores two values together
   - Syntax: pair<int,string> p = {1,"abc"};
   - Access: p.first, p.second


âœ… Conclusion
--------------
C++ STL provides powerful, efficient, and ready-to-use data structures and algorithms
that significantly reduce development time and improve code quality ðŸš€

Use STL components to write cleaner, more maintainable, and efficient C++ code ðŸ’»
